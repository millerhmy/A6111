
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A6â€™s Christmas Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Dancing+Script:wght@700&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Rubik+Scribble&family=Mountains+of+Christmas:wght@400;700&family=Cinzel+Decorative:wght@700;900&family=Noto+Serif+SC:wght@700&display=swap');
      
      @font-face {
        font-family: 'NSimSun';
        src: local('NSimSun'), url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@700&display=swap');
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #fce7f3;
        font-family: 'Nunito', sans-serif;
        cursor: none;
      }
      #root {
        width: 100vw;
        height: 100vh;
      }
    </style>
    
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
        "uuid": "https://esm.sh/uuid"
      }
    }
    </script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useRef, useEffect, useMemo, useLayoutEffect, Suspense } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame } from '@react-three/fiber';
      import { Image, Environment, OrbitControls, Stars } from '@react-three/drei';
      import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

      const TreeMode = { CHAOS: 'CHAOS', FORMED: 'FORMED', TEXT: 'TEXT', GIFT: 'GIFT' };
      const COLORS = { skyBlue: '#87CEEB', deepBlue: '#4169E1', sakuraPink: '#FFB7C5', hotPink: '#FF69B4', white: '#FFFFFF', gold: '#FFD700', foliageBlue: '#5F9EA0', foliagePink: '#DB7093' };

      const getRandomSpherePoint = (radius) => {
        const u = Math.random(), v = Math.random();
        const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
        const r = Math.cbrt(Math.random()) * radius;
        return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta) + 5, r * Math.cos(phi)];
      };

      const getConePoint = (height, baseRadius, i, total, randomness = 0) => {
        const ratio = i / total, theta = i * 2.5 + Math.random() * randomness, y = ratio * height, currentRadius = baseRadius * (1 - ratio);
        return [currentRadius * Math.cos(theta), y, currentRadius * Math.sin(theta)];
      };

      const generateTextPoints = () => {
        if (typeof document === 'undefined') return [];
        const width = 2048, height = 2048, canvas = document.createElement('canvas');
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#FFFFFF'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.font = '900 450px "Cinzel Decorative", serif'; ctx.fillText('A6', width / 2, height / 2 - 180);
        ctx.font = '700 180px "Cinzel Decorative", serif'; ctx.fillText('MERRY CHRISTMAS', width / 2, height / 2 + 200);
        const data = ctx.getImageData(0, 0, width, height).data, points = [];
        const step = 2, scale = 0.01;
        for (let y = 0; y < height; y += step) {
          for (let x = 0; x < width; x += step) {
            const i = (y * width + x) * 4;
            if (data[i] > 128) points.push([(x - width / 2) * scale, -(y - height / 2) * scale + 7.0, 0]);
          }
        }
        return points;
      };

      const getRandomTextPoint = () => {
        const pts = generateTextPoints();
        const pt = pts[Math.floor(Math.random() * pts.length)];
        return [pt[0], pt[1], pt[2] + (Math.random() - 0.5) * 1.0];
      };

      const Foliage = ({ mode }) => {
        const materialRef = useRef(null), geometryRef = useRef(null), textTransitionRef = useRef(0), COUNT = 65000, TREE_HEIGHT = 15, TREE_BASE = 5.5;
        const vertexShader = `uniform float uTime, uScale, uIsTextMode; attribute vec3 color; varying vec3 vColor, vWorldPos; void main() { vWorldPos = position; vColor = color; vec3 pos = position; vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_PointSize = uScale * mix(1.0, 1.1, uIsTextMode) * (300.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`;
        const fragmentShader = `uniform float uTime, uIsTextMode; varying vec3 vColor, vWorldPos; void main() { float dist = length(gl_PointCoord - 0.5); if (dist > 0.5) discard; float strength = pow(1.0 - (dist * 2.0), 1.5); vec3 finalColor = vColor; if (uIsTextMode > 0.01) { float g = smoothstep(5.0, 13.0, vWorldPos.y); vec3 cb = mix(vec3(0.1, 0.2, 0.9), vec3(0.2, 0.9, 1.0), g); cb += smoothstep(0.15, 0.0, abs((vWorldPos.y - 4.0) / 14.0 - fract(uTime * 0.3))) * vec3(0.5, 0.9, 1.0) * 0.5; finalColor = mix(finalColor, cb, uIsTextMode); strength = mix(strength, smoothstep(0.5, 0.3, dist), uIsTextMode); } gl_FragColor = vec4(finalColor, strength); }`;
        const { posArr, chaosArr, textArr, colArr } = useMemo(() => {
          const p = new Float32Array(COUNT * 3), c = new Float32Array(COUNT * 3), t = new Float32Array(COUNT * 3), cl = new Float32Array(COUNT * 3);
          for (let i = 0; i < COUNT; i++) {
            const tp = getConePoint(TREE_HEIGHT, TREE_BASE, i, COUNT, 1.0); p.set(tp, i * 3);
            const cp = getRandomSpherePoint(20); c.set(cp, i * 3);
            const tx = getRandomTextPoint(); t.set(tx, i * 3);
            const mixC = new THREE.Color(COLORS.foliageBlue).lerp(new THREE.Color(COLORS.foliagePink), Math.random()); cl.set([mixC.r, mixC.g, mixC.b], i * 3);
          }
          return { posArr: p, chaosArr: c, textArr: t, colArr: cl };
        }, []);
        useFrame((state, delta) => {
          if (!geometryRef.current) return;
          const curr = geometryRef.current.attributes.position.array;
          textTransitionRef.current = THREE.MathUtils.lerp(textTransitionRef.current, mode === TreeMode.TEXT ? 1 : 0, delta * 2);
          materialRef.current.uniforms.uIsTextMode.value = textTransitionRef.current;
          materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;
          for (let i = 0; i < COUNT * 3; i+=3) {
            let tar = mode === TreeMode.FORMED ? [posArr[i], posArr[i+1], posArr[i+2]] : mode === TreeMode.TEXT ? [textArr[i], textArr[i+1], textArr[i+2]] : [chaosArr[i], chaosArr[i+1], chaosArr[i+2]];
            curr[i] = THREE.MathUtils.lerp(curr[i], tar[0], delta * 1.5); curr[i+1] = THREE.MathUtils.lerp(curr[i+1], tar[1], delta * 1.5); curr[i+2] = THREE.MathUtils.lerp(curr[i+2], tar[2], delta * 1.5);
          }
          geometryRef.current.attributes.position.needsUpdate = true;
        });
        return <points><bufferGeometry ref={geometryRef}><bufferAttribute attach="attributes-position" count={COUNT} array={chaosArr.slice()} itemSize={3} /><bufferAttribute attach="attributes-color" count={COUNT} array={colArr} itemSize={3} /></bufferGeometry><shaderMaterial ref={materialRef} vertexShader={vertexShader} fragmentShader={fragmentShader} uniforms={{ uTime: { value: 0 }, uScale: { value: 0.15 }, uIsTextMode: { value: 0 } }} transparent depthWrite={false} blending={THREE.AdditiveBlending} /></points>;
      };

      const Polaroid = ({ mode, url, chaosPos, treePos, treeRot }) => {
        const ref = useRef(null), floatS = useRef(Math.random() * 0.5 + 0.2), floatO = useRef(Math.random() * Math.PI * 2);
        useFrame((state, delta) => {
          if (!ref.current) return;
          const t = state.clock.elapsedTime, tarP = new THREE.Vector3(...(mode === TreeMode.FORMED ? treePos : chaosPos));
          tarP.y += Math.sin(t * floatS.current + floatO.current) * 0.1;
          ref.current.position.lerp(tarP, delta * 2);
          let tarQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(...(mode === TreeMode.FORMED ? treeRot : [0,0,0])));
          if (mode === TreeMode.CHAOS) {
            const lookM = new THREE.Matrix4(); lookM.lookAt(ref.current.position, new THREE.Vector3(0, 5, 0), new THREE.Vector3(0, 1, 0));
            tarQ.setFromRotationMatrix(lookM);
            tarQ.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.sin(t * 0.3) * 0.1, Math.cos(t * 0.4) * 0.1, 0)));
          }
          ref.current.quaternion.slerp(tarQ, delta * 2);
          const vis = (mode === TreeMode.CHAOS || mode === TreeMode.FORMED) ? 1 : 0;
          ref.current.scale.lerp(new THREE.Vector3(vis, vis, vis), 0.1);
        });
        return <group ref={ref} position={chaosPos}><mesh position={[0,0,-0.01]}><boxGeometry args={[1.2, 1.5, 0.05]} /><meshStandardMaterial color="white" /></mesh><Image url={url} position={[0, 0.08, 0.02]} scale={[1,1]} transparent /></group>;
      };

      const PolaroidSystem = ({ mode }) => {
        const photos = useMemo(() => Array(12).fill("https://i.imgur.com/SlozniS.jpg").map(() => ({
          chaosPos: getRandomSpherePoint(20), treePos: [Math.random()*4-2, Math.random()*10+2, Math.random()*4-2], treeRot: [Math.random(), Math.random(), Math.random()]
        })), []);
        return <group>{photos.map((p, i) => <Polaroid key={i} mode={mode} url={p.url} chaosPos={p.chaosPos} treePos={p.treePos} treeRot={p.treeRot} />)}</group>;
      };

      const Experience = ({ mode }) => {
        const ctrl = useRef(null);
        useFrame((s, d) => {
          if (mode === TreeMode.CHAOS) {
            s.camera.position.lerp(new THREE.Vector3(0, 8, 28), d * 1.5);
            if (ctrl.current) { ctrl.current.target.lerp(new THREE.Vector3(0, 2, 0), d * 1.5); ctrl.current.update(); }
          }
        });
        return <><color attach="background" args={[COLORS.sakuraPink]} /><OrbitControls ref={ctrl} enablePan={false} target={[0, 2, 0]} /><ambientLight intensity={0.5} /><Environment preset="lobby" /><group position={[0, -5, 0]}><Foliage mode={mode} /><PolaroidSystem mode={mode} /></group></>;
      };

      const App = () => {
        const [mode, setMode] = useState(TreeMode.GIFT);
        return <div className="w-full h-screen bg-pink-100 relative" onDoubleClick={() => setMode(m => m === TreeMode.GIFT ? TreeMode.CHAOS : m === TreeMode.CHAOS ? TreeMode.FORMED : TreeMode.TEXT)}><Canvas camera={{ position: [0, 8, 28] }}><Experience mode={mode} /></Canvas></div>;
      };

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
